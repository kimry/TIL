# OS
# 목차

* 프로세스 & 스레드
* CPU 스케쥴러
* 동기 & 비동기
* 프로세스 동기화
* 페이징
* 가상메모리

# 프로세스 & 스레드

* 보조기억장치에 저장되어 있는 프로그램을 CPU에서 실행시키기 위해 메모리에 적재되어 있는 상태.

# CPU 스케쥴러

 * 스케쥴링 알고리즘

    * FCFS(First Come First Served)

      	* 먼저 온 사람을 먼저 대접한다는 뜻
      	* 비 선점형 스케쥴링
      	* 문제점 : 소요시간이 높은 프로세스가 CPU를 먼저 할당 받을 경우, 스케쥴링 효율성이 떨어진다.

    * SJF(Shortest Job First)

       * 소요시간이 짧은 프로세스를 먼저 CPU에 할당
       * 비 선점형 스케쥴링
       * 문제점 : 최악의 경우, 소요시간이 높은 프로세스는 평생 CPU할당을 못 받을 수 있다.

    * SRTF(Shortest Remaining Time First)

       * 남은 소요시간이 짧은 프로세스를 먼저 CPU에 할당
       * 선점형 스케쥴링
       * 문제점 : 프로세스가 도착할때마다 CPU할당을 위한 스케쥴링을 다시 해줘야 하기 때문에 높은 효율성을 기대하기 힘들다.

    * Priority

       * 우선순위가 높은 프로세스를 먼저 CPU에 할당

       * 선점형 / 비선점형 스케쥴링

       * 문제점 : 최악의 경우, 우선 순위가 낮은 프로세스는 평생 CPU할당을 못 받을 수 있다.

         > 해결책 :  aging => 우선 순위가 낮은 프로세스의 경우, 오래 기다리면 우선 순위를 높여 준다.

    * Round Robin

       * 현재 가장 대중적인 방식

       * 시분할 시스템

       * 선점형 스케쥴링

       * 장점

         > 1. 빠른 응답시간 : 모든 프로세스가 quantum 단위만큼 할당 되고 교체되기 때문에 (n-1)/q 이상 기다리지 않는다.
         >
         > 2. 프로세스 대기시간 = CPU사용시간 => 공평한 스케쥴링

      * 주의점 : quantum 단위가 커지면 FCFS와 같은 문제점을 가지게 되고 작아지면 이상적인 스케쥴링이 가능하지만 context switching overhead가 매우 증가하므로 이러한 상황들을 고려하여 적절한 quantum 단위를 설정하는 것이 중요하다. 

# 동기 & 비동기

# 프로세스 동기화

# 페이징 알고리즘

* OPT(Optimal Replacement)
  * 앞으로 가장 오래 쓰이지 않을 페이지를 교체
  * 장점
    * 가장 낮은 페이지 부재율 보장
  * 단점
    * 현실에서는 앞으로 가장 오래 쓰이지 않을 페이지를 찾는 것은 사실상 불가능
* FIFO(First In, First Out)
  * 먼저 들어온 페이지를 교체
  * 장점
    * 구현이 쉬움
  * 단점
    * 오래된 페이지일지라도 사용빈도가 높을 가능성이 있음
* LRU(Least Recently Used)
  * 가장 오랫동안 쓰이지 않은 페이지를 교체
  * OPT 알고리즘의 가장 근사한 알고리즘 => FIFO<LRU<OPT 효율성
* LFU(Least Frequently Used)
  * 사용횟수가 가장 적은 페이지를 교체
  * 단점
    * 최악의 경우, 시작시에 집중적으로 사용되고 후반에 쓰이지 않는 페이지가 교체되지 않고 계속 남아있을 가능성이 있음.
* MFU(Most Frequently Used)
  * 사용횟수가 가장 많은 페이지를 교체
* NUR(Not Used Recently)
  * 최근에 사용하지 않은 페이지를 교체
  * 최근 사용여부를 확인하기 위해 참조비트와 변형비트를 사용
* SCR(Second Change Replacement)
  * FIFO 보완한 방식으로 참조비트가 1일 경우, 한번의 기회를 더 부여하여 큐의 맨 뒤로 위치

# 가상메모리

